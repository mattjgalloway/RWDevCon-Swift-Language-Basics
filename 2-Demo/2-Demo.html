<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>2-Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{body{font-size:13px !important}img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc}.inverted pre code{color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}

@media print{
#generated-toc-clone,#generated-toc{display:none!important}
}
#generated-toc-clone li.missing,#mkreplaced-toc li.missing{list-style-type:none!important}#generated-toc-clone li, #mkreplaced-toc li{list-style-type:upper-roman}#generated-toc-clone li li, #mkreplaced-toc li li{list-style-type:decimal}#generated-toc-clone li li li,#mkreplaced-toc li li li{list-style-type:decimal-leading-zero}#generated-toc-clone li li li li,#mkreplaced-toc li li li li{list-style-type:lower-greek}#generated-toc-clone li li li li li,#mkreplaced-toc li li li li li{list-style-type:disc}#generated-toc-clone li li li li li li,#mkreplaced-toc li li li li li li{list-style-type:square}
</style>

</head>
<body class="normal firstload">
  <div id="wrapper">
      <h1 id="201:swiftlanguagebasicspart2:demoinstructions">201: Swift Language Basics, Part 2: Demo Instructions</h1>

<h2 id="introduction">Introduction</h2>

<p>Open Xcode and select <strong>File\New\Playground…</strong>. Call it <strong>ASwiftIntro.playground</strong> and save it somewhere.</p>

<p>Delete everything except:</p>

<pre><code>import UIKit
</code></pre>

<h2 id="step1–variablesstringsandstringinterpolation">Step 1 – Variables, strings and string interpolation</h2>

<p>Type:</p>

<pre><code>var conference: String = &quot;RWDevCon&quot;
</code></pre>

<p>This is a variable definition.</p>

<p>Type:</p>

<pre><code>println(&quot;The best conference is \(conference)&quot;)
</code></pre>

<p>This is printing out a line (NSLog) and this is using string interpolation.</p>

<p>Add the following line above the println:</p>

<pre><code>conference = &quot;WWDC&quot;
</code></pre>

<p>We’ve changed the variable to a new value.</p>

<p>Change the top line to:</p>

<pre><code>let conference: String = &quot;RWDevCon&quot;
</code></pre>

<p>There’s now an error, because you can’t reassign ‘let’ variables.</p>

<p>Remove:</p>

<pre><code>conference = &quot;WWDC&quot;
</code></pre>

<h2 id="step2–collectionsoptionalstuples">Step 2 – Collections, optionals, tuples</h2>

<p>Type:</p>

<pre><code>var animals: [String] = [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;, &quot;Horse&quot;]
</code></pre>

<p>This is an array. It&#8217;s declared as &#8216;var&#8217;, so we can add to it.</p>

<p>Type:</p>

<pre><code>animals.append(&quot;Cow&quot;)
</code></pre>

<p>See, we added to the array. If you change &#8216;var&#8217; to &#8216;let&#8217; then this line will show an error.</p>

<p>Type:</p>

<pre><code>animals.append(123)
</code></pre>

<p>The error comes from the fact that the array is an array of Strings, but we&#8217;re trying to add an Int. That doesn&#8217;t work. Collections are typed in Swift.</p>

<p>Type:</p>

<pre><code>for animal: String in animals {  
  println(animal)  
}
</code></pre>

<p>This is fast enumeration in Swift.</p>

<p>Turn on assistant editor - <strong>View\Assistant Editor\Show Assistant Editor</strong> - to see the output from the printing.</p>

<p>Now time to introduce optionals. Variables we’ve seen so far have always had values.</p>

<p>Type:</p>

<pre><code>var nonOptionalString: String = &quot;Dogs Are Fun&quot;  
nonOptionalString = nil
</code></pre>

<p>The last line has an error because you can’t set a variable to nil. That is, unless it’s an optional.</p>

<p>Type:</p>

<pre><code>var optionalString: String? = &quot;Dogs Are Fun&quot;  
optionalString = nil
</code></pre>

<p>The type of this variable is an “Optional String”, which can either be a String or nil.</p>

<p>Let’s now move back to collections – dictionaries this time.</p>

<p>Type:</p>

<pre><code>let farmAnimals: [String:Int] = [&quot;Dog&quot;:2, &quot;Cat&quot;:0, &quot;Cow&quot;:100]
</code></pre>

<p>This is a Dictionary in Swift. This is a <code>Dictionary</code> from <code>String</code> to <code>Int</code>.</p>

<p>Type:</p>

<pre><code>let animal: String = &quot;Dog&quot;  
let numberOfAnimals: Int? = farmAnimals[animal]
</code></pre>

<p>Here we&#8217;re accessing the Dictionary through its subscript to obtain the value for a given key, which is an optional because a value may not exist for that key.</p>

<p>Type:</p>

<pre><code>println(&quot;I have \(numberOfAnimals) \(animal)s&quot;)
</code></pre>

<p>This prints <code>&quot;I have Optional(2) Dogs&quot;</code> because the value returned from the subscript is an optional.</p>

<p>Type:</p>

<pre><code>println(&quot;I have \(numberOfAnimals!) \(animal)s&quot;)
</code></pre>

<p>This is forced unwrapping of the optional. This means that the optional&#8217;s value is taken instead of the optional itself.</p>

<p>Change the animal variable to:</p>

<pre><code>let animal: String = &quot;Mouse&quot;
</code></pre>

<p>All hell breaks loose because the optional is now its &#8216;nil&#8217; case, and it tries to unwrap that and we get a runtime crash. So this sort of unwrapping is unsafe - do it only when you know the optional can&#8217;t be nil.</p>

<p>Wrap the println like so:</p>

<pre><code>if numberOfAnimals != nil {  
  println(&quot;I have \(numberOfAnimals!) \(animal)s&quot;)  
}
</code></pre>

<p>This fixes the problem, but we can do better. We can use optional binding to make things a lot cleaner.</p>

<p>Type:</p>

<pre><code>if let numberOfAnimals: Int = farmAnimals[animal] {  
  println(&quot;I have \(numberOfAnimals) \(animal)s&quot;)  
}
</code></pre>

<p>This sets a variable called &#8216;count&#8217; local to the if-statement. The if-statement will only enter if &#8216;count&#8217; is non-nil. Inside the if-statement, &#8216;count&#8217; can be used as the unwrapped optional - i.e. it&#8217;s not an optional in here. It&#8217;s the concrete value.</p>

<p>Type:</p>

<pre><code>let tuple: (String, Int) = (&quot;RWDevCon&quot;, 180)  
println(&quot;\(tuple.0), \(tuple.1)&quot;)
</code></pre>

<p>This is a tuple. It’s a collection of values in a lightweight data structure. The data structure doesn’t need to be defined upfront like you would have done with a class in Objective-C.</p>

<p>Type:</p>

<pre><code>let namedTuple: (a: String, b: Int) = (&quot;RWDevCon&quot;, 180)  
println(&quot;\(namedTuple.a), \(namedTuple.b)&quot;)
</code></pre>

<p>You can also name the values of a tuple.</p>

<p>Type:</p>

<pre><code>for (key: String, value: Int) in farmAnimals {  
  println(&quot;\(key) =&gt; \(value)&quot;)  
}
</code></pre>

<p>Tuples are used when enumerating a dictionary. The key and value are wrapped up into a tuple.</p>

<h2 id="step3–introducingtictactoe">Step 3 – Introducing Tic Tac Toe</h2>

<p>Type:</p>

<pre><code>enum Player {  
  case X  
  case O  
}
</code></pre>

<p>This is an <code>Enum</code> in Swift. It&#8217;s much like <code>NS_ENUM</code> from Objective-C, but much more powerful as we&#8217;ll see.</p>

<p>Type:</p>

<pre><code>struct Position {  
  var column: Int  
  var row: Int  
}
</code></pre>

<p>This is a Struct in Swift. It&#8217;s like a class, in that it has members, but it is a value type.</p>

<p>Type:</p>

<pre><code>var pos1: Position = Position(column: 0, row: 0)  
var pos2: Position = pos1
</code></pre>

<p>This sets up two <code>Position</code> variables.</p>

<p>Type:</p>

<pre><code>pos1.column = 1  
println(pos1.column)  
println(pos2.column)
</code></pre>

<p>Only <code>pos1</code> has <code>column</code> set to 1. This is because <code>Struct</code>s are value types. When you assign a <code>struct</code> variable it takes a copy. If this were a class, then <code>pos1.column</code> would equal <code>pos2.column</code>.</p>

<p>Add the following method to Position:</p>

<pre><code>func asString() -&gt; String {  
  return &quot;\(column):\(row)&quot;  
}
</code></pre>

<p>Structs can have methods just like classes can.</p>

<p>Type:</p>

<pre><code>println(pos1.asString())
</code></pre>

<p>We&#8217;re using the method we just added to the struct.</p>

<p>We&#8217;re going to want to use this struct as the key in a <code>Dictionary</code>. To do this, it needs to be <code>Hashable</code>. <code>Hashable</code> is a protocol in Swift. <code>Struct</code>s can implement protocols too.</p>

<p>Change Position definitions to:</p>

<pre><code>struct Position: Hashable
</code></pre>

<p>It tells us we need to implement a few methods. The first is &#8216;hashValue&#8217;, a computed property.</p>

<p>Add the following method to Position:</p>

<pre><code>var hashValue: Int {  
  return column * 10 + row  
}
</code></pre>

<p>This is just like &#8216;hash&#8217; from <code>NSObject</code> in Objective-C.</p>

<p>One more thing needs adding for the <code>Hashable</code> protocol conformance. We need to know when two Position objects are equal. <code>Hashable</code> extends <code>Equatable</code>. To do this we need to use operator overloading.</p>

<p>Type:</p>

<pre><code>func ==(lhs: Position, rhs: Position) -&gt; Bool {  
  return lhs.column == rhs.column &amp;&amp; lhs.row == rhs.row  
}
</code></pre>

<p>This is a top-level function. It&#8217;s called <code>==</code> and takes two values - the left hand side and the right hand side of the operator, and returns a Boolean. It&#8217;s equal if the left hand side row and column equal the right hand side row and column.</p>

<p>Type:</p>

<pre><code>if pos1 == pos2 {  
  println(&quot;They're equal&quot;)  
} else {  
  println(&quot;They're not equal&quot;)  
}
</code></pre>

<p>It&#8217;s worked. Now let&#8217;s use the struct in a dictionary.</p>

<p>Type:</p>

<pre><code>var turns: [Position:Player] = [:]
</code></pre>

<p>This created an empty dictionary. We&#8217;ve had to specify the type because type inference can&#8217;t work out what types we want if the dictionary is empty.</p>

<p>Type:</p>

<pre><code>turns[pos1] = Player.X  
turns[pos2] = .O
</code></pre>

<p>We&#8217;ve used the struct as the key of the dictionary. The value is a <code>Player</code> enum. Notice the different ways of accessing the enum. In the second case we’re just using the <code>.O</code> because the compiler knows to look inside the <code>Player</code> enum because it knows that’s going to be the type of the value already.</p>

<p>This makes the start of the Tic Tac Toe game. You&#8217;ll build on this in the lab and challenge. The Position struct is the position on the game board and the <code>Player</code> enum is X or O.</p>

<p>One more thing. Type inference.</p>

<p>Go back to the top of the file and remove the <code>: String</code> from the first line.</p>

<p>Explain that it still works as expected. This is because the compiler infers the type.</p>

<p>Challenge people to go through and remove various type annotations and see what happens.</p>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>